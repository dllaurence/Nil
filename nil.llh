#ifndef NIL_LLH
#define NIL_LLH

;**********************************************************************
; nil.llh
;
; Nil global definitions.
;
; Copyright 2009-2010 by Dustin Laurence.  Distributed under the terms of
; the LGPLv3.
;
;**********************************************************************

#include "c_defs.llh"

;**********************************************************************
; Global definitions
;
;**********************************************************************

; Calling convention for all internal functions

    #define NILCC fastcc

; A small attempt to be machine word independent.  Here I assume that
; on modern machines a word is exactly the size of a generic pointer;
; this isn't true on ancient architectures, but who is going to run
; this code on anything that old?

    %Word = type %c_intptr_t
    #define WORD_T_SIZEOF C_INTPTR_T_SIZEOF
    #define WORD_T_BITSOF C_INTPTR_T_BITSOF

; The fundamental handle type by which we manipulate expressions.
; Placed here instead of in exp.llh because it decouples the headers
; of modules that use exp but are well-behaved enough to not take
; or return implementation types.

; Everything in Nil is an expression, implemented as a pointer to an
; object (of the low-level malloc() sort, not the Smalltalk or even
; C++ sort).  The pointer is represented as an integer because exp
; will be storing type tags in the low-order bits, and need to
; manipulate the bits to know the type before we know how to manipulate
; the pointer.

; Naming convention note; this isn't nil_exp because I don't think
; lisp has or needs an explicit name for this type--*EVERYTHING* is this
; type, always.

    %Exp = type %Word

#endif

