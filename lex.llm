;**********************************************************************
; lex.llm
;
; Lexer implementation.
;
; Copyright 2009 by Dustin Laurence.  Distributed under the terms of
; the LGPLv3.
;
;**********************************************************************

#include "system.llh"
#include "lex.llh"

;**********************************************************************
; Private declarations
;
;**********************************************************************

    declare NILCC %c_int @GetValidChar()

;**********************************************************************
; GetValidChar (private)
;
; Simplifies the lexer by letting us filter out illegal characters.
; Returns the ASCII value for legal character, LEX_EOF for end-of-file,
; LEX_IOERROR on a (surprise!) I/O error, or prints an error message
; and returns LEX_BADCHAR for bad characters.
;
;**********************************************************************

#define BADCHARARRAY_LEN 24
@badCharArray = internal constant [BADCHARARRAY_LEN x %c_char]
                                  c"Bad character on input.\00"

#define IOERRORARRAY_LEN 20
@ioErrorArray = internal constant [IOERRORARRAY_LEN x %c_char] c"I/O error on input.\00"

define NILCC %c_int
@GetValidChar()
{
    %nextChar = call ccc %c_int @getchar_checked()
    switch %c_int %nextChar, label %ValidIO [
        %c_int IO_EOF,      label %OnEOF
        %c_int IO_ERROR,    label %OnIOError

        %c_int ASCII_TAB,      label %AcceptNextChar
        %c_int ASCII_NEWLINE,  label %AcceptNextChar
        %c_int ASCII_VTAB,     label %AcceptNextChar
        %c_int ASCII_FORMFEED, label %AcceptNextChar
        %c_int ASCII_CR,       label %AcceptNextChar
    ]

ValidIO:
    %smallEnough = icmp slt %c_int %nextChar, ASCII_DEL
    br i1 %smallEnough, label %SmallEnough,
                        label %BadChar

SmallEnough:
    %printing = icmp sge %c_int %nextChar, ASCII_SPACE
    br i1 %printing, label %AcceptNextChar,
                     label %BadChar

AcceptNextChar:
    ret %c_int %nextChar

; This is the only exceptional return value, as we've already
; taken care of elementary error reporting

OnEOF:
    ret %c_int LEX_EOF

; Handle Exceptional Conditions

BadChar:
    %badCharMsg = getelementptr [BADCHARARRAY_LEN x %c_char]*
                        @badCharArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %badCharMsg)
    ret %c_int LEX_BADCHAR

OnIOError:
    %ioErrorMsg = getelementptr [IOERRORARRAY_LEN x %c_char]*
                        @ioErrorArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %ioErrorMsg)
    ret %c_int LEX_IOERROR
}

