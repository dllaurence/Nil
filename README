README

    Nil: Not an Implementation of Lisp

ChangeLog:

    v0.0.3 * Same behavior as v0.0.2, but now the lexer is producing
             genuine Nil symbols and the read loop is printing them
             properly.

    v0.0.2 * Recognizes and prints the tokens entered on the input line.
           * Added a welcome message and user-friendlified the input
             loop behavior.

    v0.0.1 * Echoes input lines and detects EOF, illegal characters,
             and I/O errors.

Nil is (will be, at this stage) a minimal lisp implemented directly in
handwritten LLVM Intermediate Representation ("LLVM Assembly").  See the
discussion at http://stoneknives.posterous.com for excuses as to why this is
not a deranged act (but note that you don't have to believe a word of it).  The
public repository is at http://github.com/dllaurence/Nil.

For the time being the code is licensed under the LGPL3, just so I'm
not guilty of releasing code into the wild with ambiguous terms.  But
frankly, if this is a concern for you, get help for your compulsion to
treat dangerously experimental code as more than it is. :-)

Building:

    Um...just type "make".  If it fails, figure out why and send me a
    patch.  A real build system would probably involve more red tape
    than all the Nil code.  For that matter, this README is probably
    longer than the Nil code.  :-)  You'll need LLVM and a C compiler.

Installation:

    Are you nuts?!?  I suppose you could copy the "nil" executable into
    /usr/local/bin or something.

Running:

Type "./nil" in the build directory and behold the glory.

In v0.0.3 Nil recognizes and lists the tokens entered on the input line
separated with spaces.  The interaction loop quits when EOF or an I/O error is
encountered, and warns about bad characters on the input.

You can always tell exactly what nil thinks is a token because tokens are
always separated by a single space and tokens can never contain spaces; for
example, '(' and ')' are treated as single tokens in their own right separate
from symbol strings.  At this point it accepts more characters as symbol
characters than even lisp should, but that's not worth fixing right now.

Note that while this is the same user-visible behavior as in v0.0.2, internally
the tokens are now being handled as true lisp symbols, which is a notable
advance.

HACKING

While there isn't much there yet, it's on github to be played with.  Note that
this is *very* unstable development code. :-)  While portability is a minor
concern at the moment the code has been built (if I felt like it) with LLVM 2.5
on x86 Fedora 11 as well as the with LLVM 2.6 on AMD64 Fedora 12 Linux.
However, LLVM should take care of most machine dependencies and it aspires to
be reasonably portable someday when it grows up, so report gross incivilities
in the github issue tracker.

This will help you know where to look first:

Conventions:

*.llm         IR source modules, to be preprocessed with CPP.
*.llh         Module declarations for #include

Code overview:

Makefile      I assume you know what this is.

Skel/         Skeleton source .llm, .llh, and test files

Main Nil implementation files:

nil.llh       Global declarations (types, #defines) for all source files.

nil.llm       has main(), and often modules not yet broken out into their
              own files.  Also documentation you will want to read.

System support files:

c_defs.c      A simple C program that writes things Nil needs to know
              about the local C implementation (e.g. the types needed
              to call into libc) into c_defs.llh

system_c.c    Some C functions callable from LLVM to obtain things not
              available through c_defs.llh (e.g. the stdio FILE pointers
              for stdin and stdout).

system_ll.llm Misc. utility functions, such as an LLVM assert() and nicer
              wrappers for particularly annoying libc functions.  Nothing
              in system_ll.llm, system_c.c, or system.llh should depend
              on the actual nil implementation, which means the code there
              should use the C calling convention and the C/libc types.

system.llh    #includes c_defs.llh, declares prototypes of useful libc
              functions (so LLVM knows their signatures and can typecheck
              calls) plus the prototypes for the functions in system_c.c
              and system_ll.llm, defines ASCII convenience constants, etc.

lex.llh/m     The nil lexer.  This should only depend on c_defs, system,
              and nil.llh--nothing here should use the expression code.
              That means the Lexemes get turned into Nil expressions
              elsewhere.

exp.llh/m     The expression implementation, plus support code such as
              unique strings.

