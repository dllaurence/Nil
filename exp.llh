#ifndef EXP_LLH
#define EXP_LLH

;**********************************************************************
; exp.llh
;
; Public declarations for the Expression module.
;
; Copyright 2009-2010 by Dustin Laurence.  Distributed under the terms of
; the LGPLv3.
;
;**********************************************************************

#include "nil.llh"

;FIXME: quite a bit of this header should be private

; Fundamental types

; The fundamental handle type by which we manipulate expressions.
; Everything in Nil is an expression, implemented (usually) as a pointer
; to an object (of the low-level malloc() sort, not the Smalltalk or
; even C++ sort).  The pointer is represented as an integer because exp
; will be storing type tags in the low-order bits, and need to
; manipulate the bits to know the type before we know how to manipulate
; the pointer.

; Naming convention note; this isn't nil_exp because I don't think
; lisp has or needs an explicit name for this type--*EVERYTHING* is this
; type, always.

    %Exp = type %Word

    ; This is our representation, though we don't actually need it explicit
    ; It would have been better to use this anyway, but I did not.
    ;%nil_symbol = type %c_char

    %nil_cell = type {%Exp, %Exp}

    ; Internal representation--a primitive is a native function over
    ; expressions.  The word is the required number of arguments so
    ; the interpreter can do some sanity checking, and the string is
    ; a printing format
    %nil_primitive = type {%Exp (%Exp)*, %Word, %c_char*}

; Tag field type values.

    ; This and the *_TAG constants are the only places where the code
    ; assumes the size of the tag field, so it can be extended as needed
    ; simply by changing the type here.
    %Tag = type i2
    #define MAX_TAG 3

    ; For now, these values are randomly chosen to ensure the code
    ; is clean and not depending on particular bit patterns.  They should
    ; fit insize a %Tag type (or they'll be silently wrapped), but otherwise
    ; are arbitrary.
    #define    SYMBOL_TAG  0
    #define      CELL_TAG  1
    #define PRIMITIVE_TAG  2

    ; We define Nil as the null symbol (or at least not as the null CELL,
    ; which is an obvious choice as nil is the empty list) instead of the
    ; null cell because it makes testing for a non-null cell a single
    ; comparison.  The code *does* assume this (most especially it assumes
    ; NIL does not have CELL_TAG).
    #define   NIL_VALUE SYMBOL_TAG

; Low-level manipulation of the tags embedded in the low-order bits.
    ; FIXME: these trivial functions should *always* be inlined
    declare NILCC %Tag @GetTag(%Exp %exp)
    declare NILCC i1   @TagIs(%Exp %exp, %Tag %tag)
    declare NILCC i1   @TagIsNot(%Exp %exp, %Tag %tag)
    declare NILCC i1   @SameTag(%Exp %lhs, %Exp %rhs)
    declare NILCC %Exp @ClearTag(%Exp %exp)
    declare NILCC %Exp @AddTag(%Exp %exp, %Tag %tag)
    declare NILCC %Exp @SetTag(%Exp %exp, %Tag %tag)
    declare NILCC i1 @TagIsClear(%Exp %exp)

; Conversions

    ; Symbol
    declare NILCC %Exp     @str2Exp(%c_char* %str)
    declare NILCC %c_char* @Exp2str(%Exp %exp)

    ; List
    declare NILCC %Exp       @nil_cell2Exp(%nil_cell* %cell)
    declare NILCC %nil_cell* @Exp2nil_cell(%Exp       %exp)

    ; Primitive
    declare NILCC %Exp            @nil_primitive2Exp(%nil_primitive* %prim)
    declare NILCC %nil_primitive* @Exp2nil_primitive(%Exp            %exp)

; The "seven primitive operators" of Paul Graham's paper, plus
; internal forms

    ; #2 -- atom
    declare NILCC i1 @IsAtom(%Exp %exp) ; Internal form

    ; #3 -- eq (see notes on whether this is precisely Graham's eq
    ; Internal form
    declare NILCC i1 @Eq(%Exp %lhs, %Exp %rhs)
    declare NILCC i1 @NotEq(%Exp %lhs, %Exp %rhs)

    ; #4 -- car
    declare NILCC %Exp @nil_car(%Exp %exp)

    ; #5 -- cdr
    declare NILCC %Exp @nil_cdr(%Exp %exp)

    ; #6 -- cons
    declare NILCC %Exp @nil_cons(%Exp %car, %Exp %cdr)

; Other tests

    declare NILCC i1 @IsSymbol(%Exp %exp)
    declare NILCC i1 @IsCell(%Exp %exp)
    declare NILCC i1 @IsPrimitive(%Exp %exp)
    declare NILCC i1 @IsNil(%Exp %exp)
    declare NILCC i1 @NotNull(%Exp %exp)

; Other symbol manipulations

    ; The interfaces are somewhat inconsistent, but convenient
    declare NILCC %Exp       @NewSymbol(%c_char* %name)
    declare NILCC %nil_cell* @NewCell()
    declare NILCC %Exp       @NewPrimitive(%Exp (%Exp)*, %Word %argCount,
                                           %c_char* %printForm)

; Expression I/O
    declare NILCC void @PrintExp(%Exp %exp)

#endif

