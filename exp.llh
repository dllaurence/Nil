#ifndef EXP_LLH
#define EXP_LLH

;**********************************************************************
; exp.llh
;
; Public declarations for the Expression module.
;
; Copyright 2009-2010 by Dustin Laurence.  Distributed under the terms of
; the LGPLv3.
;
;**********************************************************************

#include "nil.llh"

;FIXME: quite a bit of this header should be private

; Fundamental types

    ; N.B. The fundamental %Exp type is defined in nil.llh

    %nil_cell = type {%Exp, %Exp}

; Tag field type values.

    ; This and the *_TAG constants are the only places where the code
    ; assumes the size of the tag field, so it can be extended as needed
    ; simply by changing the type here.
    %Tag = type i3
    #define MAX_TAG 7

    ; For now, these values are randomly chosen to ensure the code
    ; is clean and not depending on particular bit patterns.  They should
    ; fit insize a %Tag type (or they'll be silently wrapped), but otherwise
    ; are arbitrary.
    #define SYMBOL_TAG  3
    #define   CELL_TAG  7

    ; We define Nil as the null symbol instead of the null cell because
    ; it makes testing for a non-null cell a single comparison.  The
    ; code *does* assume this (most especially it assumes NIL does not
    ; have CELL_TAG.
    #define   NIL SYMBOL_TAG

; Low-level manipulation of the tags embedded in the low-order bits.
    ; FIXME: these trivial functions should *always* be inlined
    declare NILCC %Tag @GetTag(%Exp %exp)
    declare NILCC %Exp @ClearTag(%Exp %exp)
    declare NILCC %Exp @AddTag(%Exp %exp, %Tag %tag)
    declare NILCC %Exp @SetTag(%Exp %exp, %Tag %tag)
    declare NILCC i1 @TagIsClear(%Exp %exp)

; Conversions

    ; Symbol
    declare NILCC %Exp     @str2Exp(%c_char* %str)
    declare NILCC %c_char* @Exp2str(%Exp %exp)

    ; List
    declare NILCC %Exp       @nil_cell2Exp(%nil_cell* %cell)
    declare NILCC %nil_cell* @Exp2nil_cell(%Exp       %exp)

; The "seven primitive operators" of Paul Graham's paper, plus
; internal forms

    ; #2 -- atom
    declare NILCC i1 @Atom(%Exp %exp)

    ; #4 -- car
    declare NILCC %Exp @nil_car(%Exp %exp)

    ; #5 -- cdr
    declare NILCC %Exp @nil_cdr(%Exp %exp)

    ; #6 -- cons
    declare NILCC %Exp @nil_cons(%Exp %car, %Exp %cdr)

; Other tests

    declare NILCC i1 @Cell(%Exp %exp)

; Other symbol manipulations

    declare NILCC %Exp @NewSymbol(%c_char* %name)

; Expression I/O
    declare NILCC void @PrintExp(%Exp %exp)

#endif

