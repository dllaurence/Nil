;**********************************************************************
; nil.llm
;
; Nil main program

; Coding conventions: all native quantities that have a direct correspondence
; with something in lisp are named "nil_<name>" where <name> is the name
; recognized by Nil.
;
; Similarly, all quantities imported from C source have a "c_" prefix
; (obviously quantites defined in libc, such as printf, have their standard
; name).
;
; The above rules apply to macros, but in all caps.
;
; Everything else is an implementation-defined quantity not visible to
; Nil.  They are in my C++ camel case convention (initial cap is a type
; or function, initial small is a variable) to further distinguish them
; from the above.  Also, I am using a 'p' prefix to denote pointers where
; it seems to clarify the code, but probably not consistently.
;
; Finally, to avoid horrible confusion, when it appear by itself or in English
; text the name of the language Nil is always capitalized and the name of the
; empty list nil is always in all lowercase.
;
; Organization: basically like C, with .llh #include files for public module
; declarations and .llm module implementation files.  Note that for ease of
; development I have not always divided the project into as many modules as
; it would have for a finished work, however the modules should be obvious and
; easily broken out as becomes convenient.  Also note that the c_defs and
; system modules have different rules.
;
; Cheats:
;
;   * Using malloc()
;   * Using getchar and other stdio functions instead of read() and write().
;   * Using the C string-handling functions.  Would prefer counted
;     strings anyway.
;
; Copyright 2009-2010 by Dustin Laurence.  Distributed under the terms of
; the LGPLv3.
;
;**********************************************************************

#include "nil.llh"
#include "system.llh"
#include "exp.llh"
#include "memory.llh"
#include "parse.llh"

; For now, we'll leave the definition here in the main module.
; For now, we are maintaining the definition here and the declarations
; in other files by hand because LLVM would call this a redefinition of
; an external declaration. :-(
    @exceptionCode = global %Word 0

;**********************************************************************
; nil_quit
;
;**********************************************************************

    #define QUITARRAY_LEN 5
    %QuitArrayType = type [QUITARRAY_LEN x %c_char]
    @quitArray = internal constant %QuitArrayType c"quit\00"

define NILCC %Exp
@nil_quit(%Exp %exp)
{
    ; Ignore inputs
    call ccc void @exit(%c_int 0)
    unreachable
    ret %Exp NIL_VALUE
}

;**********************************************************************
; GetEnv
;
; Constructs the top-level environment
;
;**********************************************************************

define NILCC %Exp
@GetEnv()
{
    %quitStr = getelementptr %QuitArrayType* @quitArray, i64 0, i64 0
    %quitPrim = call NILCC %Exp @NewPrimitive(%Exp (%Exp)* @nil_quit,
                                          %Word -1, %c_char* %quitStr)
    %quitSym = call NILCC %Exp @NewSymbol(%c_char* %quitStr)
    ; FIXME: This is a dotted pair!!!
    %quitCDR = call NILCC %Exp @nil_cons(%Exp %quitPrim, %Exp NIL_VALUE)
    %quitAssoc = call NILCC %Exp @nil_cons(%Exp %quitSym,
                                           %Exp %quitCDR)
    %assocList1 = call NILCC %Exp @nil_cons(%Exp %quitAssoc,
                                            %Exp NIL_VALUE)

#if 0
; Debugging code to show the binding list on startup
call %c_int @putchar(%c_int ASCII_NEWLINE)
call NILCC void @PrintExp(%Exp %assocList1)
call %c_int @putchar(%c_int ASCII_NEWLINE)
#endif

    ret %Exp %assocList1
}

;**********************************************************************
; nil_assoc
;
; Takes a list of associations, where each association is a list with
; the key in the first position.  This is probably the same as assoc
; in standard lisp.
;
; We'll only use two-element associations, but the code is general for
; re-use in-language.  For that reason, this should perhaps move to
; the exp module, or a separate library of primitives.
;
;**********************************************************************

    #define EXPECTEDLISTARRAY_LEN 21
    %ExpectedListType = type [EXPECTEDLISTARRAY_LEN x %c_char]
    @expectedListArray = internal constant %ExpectedListType
        c"assoc: expected list\00"

    #define EXPECTEDBINDINGARRAY_LEN 24
    %ExpectedBindingType = type [EXPECTEDBINDINGARRAY_LEN x %c_char]
    @expectedBindingArray = internal constant %ExpectedBindingType
        c"assoc: expected binding\00"

define NILCC %Exp
@nil_assoc(%Exp %key, %Exp %assocList)
{
    %isList = call NILCC i1 @IsCell(%Exp %assocList)
    br i1 %isList, label %HaveList, label %HaveAtomTag

HaveAtomTag:
    %haveNil = call NILCC i1 @IsNil(%Exp %assocList)
    br i1 %haveNil, label %HaveNil, label %HaveAtom

HaveNil:
    ; The empty list is a list that contains no bindings, so valid
    ; This is our "not found" return value
    ret %Exp NIL_VALUE

HaveAtom:
    ; This is an error, throw an exception
    %expectedListPtr = getelementptr %ExpectedListType*
        @expectedListArray, i64 0, i64 0
    call %c_int @puts(%c_char* %expectedListPtr)
    br label %Exception

Exception:
    %xpn = call NILCC %Exp @Exception2Exp(%Word NIL_EXPECTED_LIST)
    ret %Exp %xpn

HaveList:
    %firstBinding = call NILCC %Exp @nil_car(%Exp %assocList)

    ; Is this really a binding?  It needs to be a cell, but
    ; can be arbitrary otherwise
    %isBinding = call NILCC i1 @IsCell(%Exp %firstBinding)
    br i1 %isBinding, label %HaveBinding, label %NotBinding

NotBinding:
    ; we can't interpret this object, so throw an exception
    ; This is an error, throw an exception
    %expectedBindingPtr = getelementptr %ExpectedBindingType*
        @expectedBindingArray, i64 0, i64 0
    call %c_int @puts(%c_char* %expectedBindingPtr)
    br label %Exception

HaveBinding:
    ; Does the first entry have the key?
    %thisKey = call NILCC %Exp @nil_car(%Exp %firstBinding)
    %notFound = call NILCC i1 @NotEq(%Exp %key, %Exp %thisKey)
    br i1 %notFound, label %NotFound, label %Found

Found:
    ; Note that we return the entire association--this allows,
    ; among other things, distinguishing between finding a nil
    ; value and finding no value
    ret %Exp %firstBinding

NotFound:
    %restAssoc = call NILCC %Exp @nil_cdr(%Exp %assocList)
    ; Trivial tail call
    %binding = call NILCC %Exp @nil_assoc(%Exp %key, %Exp %restAssoc)

    ret %Exp %binding
}

;**********************************************************************
; EnvLookup
;
;**********************************************************************

    #define UNKNOWNSYMBOLARRAY_LEN 16
    %UnknownSymbolType = type [UNKNOWNSYMBOLARRAY_LEN x %c_char]
    @unknownSymbolArray = internal constant %UnknownSymbolType
        c"unknown symbol \00"

define NILCC %Exp
@EnvLookup(%Exp %exp, %Exp %env)
{
    ; FIXME: change from using assoc lists to using environments
    ; (lists of assoc lists)
    %binding = call NILCC %Exp @nil_assoc(%Exp %exp, %Exp %env)

        #ifndef NDEBUG
        ; When used internally, should be impossible for assoc
        ; to throw an exception
        %notException = call NILCC i1 @NotException(%Exp %binding)
        assert(%notException)
        #endif

    %found = call NILCC i1 @NotNil(%Exp %binding)
    br i1 %found, label %FoundSymbol, label %UnknownSymbol

UnknownSymbol:
    %unknownSymbolPtr = getelementptr
        %UnknownSymbolType* @unknownSymbolArray, i64 0, i64 0
    call %c_int @putstring(%c_char* %unknownSymbolPtr)
    call NILCC void @PrintExp(%Exp %exp)
    call %c_int @putchar(%c_int ASCII_NEWLINE)
    %xpn = call NILCC %Exp @Exception2Exp(%Word NIL_UNKNOWN_SYMBOL)
    ret %Exp %xpn

FoundSymbol:
    %cdr = call NILCC %Exp @nil_cdr(%Exp %binding)

        #ifndef NDEBUG
        ; Must be a list
        %isCell = call NILCC i1 @IsCell(%Exp %cdr)
        assert(%isCell)
        ; Must be a 1-element list--we have no good use for anything
        ; else!
        %cddr = call NILCC %Exp @nil_cdr(%Exp %cdr)
        %isNil = call NILCC i1 @IsNil(%Exp %cddr)
        assert(%isNil)
        #endif

    %cadr = call NILCC %Exp @nil_car(%Exp %cdr)
    ret %Exp %cadr
}

;**********************************************************************
; Eval
;
;**********************************************************************

define NILCC %Exp
@Eval(%Exp %exp, %Exp %env)
{
;call %c_int @putchar(%c_int ASCII_E)
    %tag = call NILCC %Tag @GetTag(%Exp %exp)

        ; Remember that here we will only see types produced by the
        ; parser, not all types in the language, and the top level
        ; caller will filter out parser exceptions for us.

    switch %Tag %tag, label %CantHappen [
        %Tag CELL_TAG,      label %Cell
        %Tag SYMBOL_TAG,    label %SymbolTag
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

Cell:
    ; I claim apply should control the evaluation of its arguments,
    ; so contrary to SICP we just pass the expression on
    %return = call NILCC %Exp @Apply(%Exp %exp, %Exp %env)
    ret %Exp %return

SymbolTag:
    ;%evalExp = call NILCC %Exp @EnvLookup(%Exp %exp, %Exp %env)
    ;ret %Exp %evalExp

    %notNil = call NILCC i1 @NotNil(%Exp %exp)
    br i1 %notNil, label %Symbol, label %SelfEvaluate
    ; for now
    ;br label %IsNil

SelfEvaluate:
    ; nil is self-evaluating
    ret %Exp %exp

Symbol:
    ; May be an exception
    %value = call NILCC %Exp @EnvLookup(%Exp %exp, %Exp %env)
#if 0
; Debugging code to print the symbol found in angle brackets
call %c_int @putchar(%c_int ASCII_LANGLE)
call NILCC void @PrintExp(%Exp %value)
call %c_int @putchar(%c_int ASCII_RANGLE)
call %c_int @putchar(%c_int ASCII_NEWLINE)
#endif
    ret %Exp %value
}

;**********************************************************************
; Apply
;
;**********************************************************************

    #define CANNOTAPPLYARRAY_LEN 14
    %CannotApplyType = type [CANNOTAPPLYARRAY_LEN x %c_char]
    @cannotApplyArray = internal constant %CannotApplyType
        c"cannot apply \00"

define NILCC %Exp
@Apply(%Exp %combination, %Exp %env)
{
Initial:
;call %c_int @putchar(%c_int ASCII_A)

        #ifndef NDEBUG
        %isCell = call NILCC i1 @IsCell(%Exp %combination)
        assert(%isCell)
        #endif

    %car = call NILCC %Exp @nil_car(%Exp %combination)

    ; For now, always evaluate the function.  This may have to
    ; change when we get to implementing user functions and
    ; lambda, we'll see
    %fn = call NILCC %Exp @Eval(%Exp %car, %Exp %env)

    %tag = call NILCC %Tag @GetTag(%Exp %fn)

        ; Remember that here we will only see types produced by the
        ; parser, not all types in the language, and the top level
        ; caller will filter out parser exceptions for us.

    switch %Tag %tag, label %CantHappen [
        %Tag EXCEPTION_TAG, label %Exception
        %Tag CELL_TAG,      label %CannotApply
        %Tag SYMBOL_TAG,    label %CannotApply
        %Tag PRIMITIVE_TAG, label %Primitive
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

Exception:
    ret %Exp %fn

CannotApply:
    %cannotApplyPtr = getelementptr %CannotApplyType* @cannotApplyArray,
                                     i64 0, i64 0
    call %c_int @putstring(%c_char* %cannotApplyPtr)
    call NILCC void @PrintExp(%Exp %fn)
    call %c_int @putchar(%c_int ASCII_NEWLINE)
    %xpn = call NILCC %Exp @Exception2Exp(%Word NIL_CANNOT_APPLY)
    ret %Exp %xpn

Primitive:
    %prim = call NILCC %nil_primitive* @Exp2nil_primitive(%Exp %fn)
    %primFnPtr = getelementptr %nil_primitive* %prim, i64 0, i32 0
    %primFn = load %Exp (%Exp)** %primFnPtr

    %cdr = call NILCC %Exp @nil_cdr(%Exp %combination)
    ; We don't evaluate the args before calling--*all* primitives
    ; are magic
    %result = call NILCC %Exp %primFn(%Exp %cdr)
    ret %Exp %result
}

;**********************************************************************
; EvalList
;
;**********************************************************************

#define DOTPAIRARRAY_LEN 36
%DotPairType = type [DOTPAIRARRAY_LEN x %c_char]
@dotPairArray = internal constant %DotPairType
    c"Error: can't evaluate a dotted pair\00"

define NILCC %Exp
@EvalList(%Exp %exp, %Exp %env)
{
;call %c_int @putchar(%c_int ASCII_L)
    %isAtom = call NILCC i1 @IsAtom(%Exp %exp)
    br i1 %isAtom, label %Atom, label %Cell

Atom:
    %isNil = call NILCC i1 @IsNil(%Exp %exp)
    br i1 %isNil, label %IsNil, label %NotNil

IsNil:
    ret %Exp %exp

NotNil:
    ; FIXME: when we have the ability to produce dotted pairs,
    ; this code needs to be tested
    ; Weird--evaluating a dotted pair
    %dotPairString = getelementptr %DotPairType* @dotPairArray,
                                                    i64 0, i64 0
    call ccc %c_int @puts(%c_char* %dotPairString)
    call %c_int @putchar(%c_int ASCII_NEWLINE)
    %errorExp = call NILCC %Exp @Exception2Exp(%Word NIL_EVAL_DOTPAIR)
    ret %Exp %errorExp

Cell:
    %car = call NILCC %Exp @nil_car(%Exp %exp)
    %first = call NILCC %Exp @Eval(%Exp %car, %Exp %env)
    %firstOK = call NILCC i1 @NotException(%Exp %first)
    br i1 %firstOK, label %DoCDR, label %Exception

DoCDR:
    %cdr = call NILCC %Exp @nil_cdr(%Exp %exp)
    %rest = call NILCC %Exp @EvalList(%Exp %cdr, %Exp %env)
    %restOK = call NILCC i1 @NotException(%Exp %rest)
    br i1 %restOK, label %DoCons, label %Exception

DoCons:
    %cons = call NILCC %Exp @nil_cons(%Exp %first, %Exp %rest)
    ret %Exp %cons

Exception:
    %xpn = phi %Exp [%first, %Cell], [%rest, %DoCDR]
    ret %Exp %xpn
}

;**********************************************************************
; DiscardLine
;
;**********************************************************************

define NILCC void
@DiscardLine()
{
    br label %Loop

Loop:
    %parseExp = call NILCC %ParseExp @GetParseExp()
    %parseExpType = extractvalue %ParseExp %parseExp, 0

    switch %c_int %parseExpType, label %Loop [

        %c_int NIL_EXCEPTION, label  %Exception

        %c_int ASCII_NEWLINE,  label %Done
    ]

Exception:
    %exception = extractvalue %ParseExp %parseExp, 1
    switch %Exp %exception, label %CantHappen [

        %Exp NIL_EOF,          label %Done
        %Exp NIL_IOERROR,      label %Done
        %Exp NIL_BADCHAR,      label %Loop
        %Exp NIL_EXTRA_RPAREN, label %Loop
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

Done:
    call NILCC void @UngetParseExp(%ParseExp %parseExp)
    ret void
}

;**********************************************************************
; NewlineIf
;
;**********************************************************************

define NILCC void
@NewlineIf(i1 %cond)
{
    br i1 %cond, label %Newline, label %Done

Newline:
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    br label %Done

Done:
    ret void
}

;**********************************************************************
; PrintWelcome
;
;**********************************************************************

    #define WELCOMEARRAY_LEN 62
    @welcomeArray = internal constant [WELCOMEARRAY_LEN x %c_char]
        c"Welcome to nil v0.0.7.  Enter '(quit)' at the prompt to exit.\00"

define NILCC void
@PrintWelcome()
{
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    %welcomeString = getelementptr [WELCOMEARRAY_LEN x %c_char]*
                                           @welcomeArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %welcomeString)
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)

    ret void
}

;**********************************************************************
; PrintPrompt
;
;**********************************************************************

    #define KNOWNARRAY_LEN 16
    @knownArray = internal constant [KNOWNARRAY_LEN x %c_char]
        c"Known strings: \00"

    #define PROMPTARRAY_LEN 6
    @promptArray = internal constant [PROMPTARRAY_LEN x %c_char]
        c"nil> \00"

define NILCC void
@PrintPrompt()
{
#if 0
    ; Show the current list of strings before each new prompt
    %knownStr = getelementptr [KNOWNARRAY_LEN x %c_char]* @knownArray,
                                                          i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %knownStr)
    call NILCC void @PrintAllStrings()
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
#endif

    ; Print the prompt
    %promptString = getelementptr [PROMPTARRAY_LEN x %c_char]*
                                           @promptArray, i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %promptString)

    ret void
}

;**********************************************************************
; PrintResultPrefix
;
;**********************************************************************

    #define RESULTARRAY_LEN 9
    %ResultArrayType = type [RESULTARRAY_LEN x %c_char]
    @resultArray = internal constant %ResultArrayType
        c"    ==> \00"

define NILCC void
@PrintResultPrefix()
{
    %resultString = getelementptr %ResultArrayType*
                                           @resultArray, i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %resultString)

    ret void
}

;**********************************************************************
; HandleParserException
;
;**********************************************************************

    #define BADCHARARRAY_LEN 16
    @badCharArray = internal constant [BADCHARARRAY_LEN x %c_char]
        c"#bad character#\00"

    #define IOERRORARRAY_LEN 20
    @ioErrorArray = internal constant [IOERRORARRAY_LEN x %c_char]
        c"I/O error on input.\00"

    #define RPARENARRAY_LEN 14
    @rParenArray = internal constant [RPARENARRAY_LEN x %c_char]
        c"Unmatched ')'\00"

define i1
@HandleParserException(%Exp %code)
{
    switch %Exp %code, label %CantHappen [

        %Exp NIL_EOF,          label %EOF
        %Exp NIL_IOERROR,      label %IOError
        %Exp NIL_BADCHAR,      label %BadChar
        %Exp NIL_EXTRA_RPAREN, label %ExtraRParen
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

EOF:
    ret i1 false

IOError:
    %ioErrorMsg = getelementptr [IOERRORARRAY_LEN x %c_char]*
                        @ioErrorArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %ioErrorMsg)
    ret i1 false

BadChar:
    %badCharMsg = getelementptr [BADCHARARRAY_LEN x %c_char]*
                        @badCharArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %badCharMsg)
    call NILCC void @DiscardLine()
    ret i1 true

ExtraRParen:
    %rParenMsg = getelementptr [RPARENARRAY_LEN x %c_char]*
                        @rParenArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %rParenMsg)
    call NILCC void @DiscardLine()
    ret i1 true
}

;**********************************************************************
; main
;
;**********************************************************************

define %c_int
@main(%c_int %argc, %c_char **%argv)
{
    ; This flag is necessary to avoid double-spacing the prompt when
    ; nothing was entered.
    %hadInputPtr = alloca i1
    store i1 0, i1* %hadInputPtr

    ; The initial evaluation environment
    %env = call NILCC %Exp @GetEnv()

    call NILCC void @PrintWelcome()
    br label %Prompt

Prompt:
    call NILCC void @PrintPrompt()
    br label %ReadExp

ReadExp:
    %parseExp = call NILCC %ParseExp @Read()
    %code = extractvalue %ParseExp %parseExp, 0
    ; Because of single assignment, this is more convenient
    ; to load here even though only Newline and the exception
    ; handlers need it
    %hadInput = load i1* %hadInputPtr

    switch %c_int %code, label %CantHappen [

        %c_int NIL_EXCEPTION, label  %ParseException

        %c_int ASCII_NEWLINE,  label %NewLine

        %c_int NIL_SYMBOL,   label   %EvalExp
        %c_int NIL_CELL,     label   %EvalExp
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

ParseException:
    call NILCC void @NewlineIf(i1 %hadInput)
    %exception = extractvalue %ParseExp %parseExp, 1
    %continue = call NILCC i1 @HandleParserException(%Exp %exception)
    store i1 0, i1* %hadInputPtr
    br i1 %continue, label %ReadExp, label %Exit

NewLine:
    call NILCC void @NewlineIf(i1 %hadInput)
    store i1 0, i1* %hadInputPtr
    br label %Prompt

EvalExp:
    %unevalExp = extractvalue %ParseExp %parseExp, 1
    %exp = call NILCC %Exp @Eval(%Exp %unevalExp, %Exp %env)
    call NILCC void @PrintResultPrefix()
    call NILCC void @PrintExp(%Exp %exp)

    ; If we got an exception, toss the rest of the line
    %evalOK = call NILCC i1 @NotException(%Exp %exp)
    br i1 %evalOK, label %EvalOK, label %EvalException

EvalException:
    call NILCC void @DiscardLine()
    br label %EvalOK

EvalOK:
    call ccc %c_int @putchar(%c_int ASCII_SPACE)
    store i1 1, i1* %hadInputPtr
    br label %ReadExp

Exit:
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    ret %c_int 0
}

