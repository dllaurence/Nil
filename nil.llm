;**********************************************************************
; nil.llm
;
; Nil main program

; Coding conventions: all native quantities that have a direct correspondence
; with something in lisp are named "nil_<name>" where <name> is the name
; recognized by Nil.
;
; Similarly, all quantities imported from C source have a "c_" prefix
; (obviously quantites defined in libc, such as printf, have their standard
; name).
;
; The above rules apply to macros, but in all caps.
;
; Everything else is an implementation-defined quantity not visible to
; Nil.  They are in my C++ camel case convention (initial cap is a type
; or function, initial small is a variable) to further distinguish them
; from the above.  Also, I am using a 'p' prefix to denote pointers where
; it seems to clarify the code, but probably not consistently.
;
; Finally, to avoid horrible confusion, when it appear by itself or in English
; text the name of the language Nil is always capitalized and the name of the
; empty list nil is always in all lowercase.
;
; Organization: basically like C, with .llh #include files for public module
; declarations and .llm module implementation files.  Note that for ease of
; development I have not always divided the project into as many modules as
; it would have for a finished work, however the modules should be obvious and
; easily broken out as becomes convenient.  Also note that the c_defs and
; system modules have different rules.
;
; Cheats:
;
;   * Using malloc()
;   * Using getchar and other stdio functions instead of read() and write().
;   * Using the C string-handling functions.  Would prefer counted
;     strings anyway.
;
; Copyright 2009-2010 by Dustin Laurence.  Distributed under the terms of
; the LGPLv3.
;
;**********************************************************************

#include "nil.llh"
#include "system.llh"
#include "exp.llh"
#include "memory.llh"
#include "parse.llh"

; For now, we'll leave the definition here in the main module.
; For now, we are maintaining the definition here and the declarations
; in other files by hand because LLVM would call this a redefinition of
; an external declaration. :-(
    @exceptionCode = global %Word 0


;**********************************************************************
; EnvLookup
;
;**********************************************************************

define NILCC %Exp
@EnvLookup(%Exp %exp, %Exp %env)
{
    ret %Exp %exp
}

;**********************************************************************
; Eval
;
;**********************************************************************

define NILCC %Exp
@Eval(%Exp %exp, %Exp %env)
{
    %tag = call NILCC %Tag @GetTag(%Exp %exp)

    switch %Tag %tag, label %CantHappen [

        ; Remember that here we will only see types produced by the
        ; parser, not all types in the language
        %Tag CELL_TAG,      label %Cell
        %Tag SYMBOL_TAG,    label %SymbolTag
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

Cell:
    %car = call NILCC %Exp @nil_car(%Exp %exp)
    %cdr = call NILCC %Exp @nil_cdr(%Exp %exp)
    %args = call NILCC %Exp @EvalList(%Exp %cdr, %Exp %env)
    ; Or, possibly, cons them together so (apply fn arg*) works?
    %result = call NILCC %Exp @Apply(%Exp %car, %Exp %args, %Exp %env)
    ret %Exp %result

SymbolTag:
    %evalExp = call NILCC %Exp @EnvLookup(%Exp %exp, %Exp %env)
    ret %Exp %evalExp
}

;**********************************************************************
; Apply
;
;**********************************************************************

#define APPLYARRAY_LEN 6
@applyArray = internal constant [APPLYARRAY_LEN x %c_char]
    c"apply\00"

define NILCC %Exp
@Apply(%Exp %fnExp, %Exp %args, %Exp %env)
{
    ; For now, just say what we'd do
    %applyPtr = getelementptr [APPLYARRAY_LEN x %c_char]* @applyArray,
                                      i64 0, i64 0

    %applySymbol = call NILCC %Exp @NewSymbol(%c_char* %applyPtr)

    %fn = call NILCC %Exp @Eval(%Exp %fnExp, %Exp %env)

    %applyArgs = call NILCC %Exp @nil_cons(%Exp %fn, %Exp %args)
    %result = call NILCC %Exp @nil_cons(%Exp %applySymbol, %Exp %applyArgs)

    ret %Exp %result
}

;**********************************************************************
; EvalList
;
;**********************************************************************

define NILCC %Exp
@EvalList(%Exp %exp, %Exp %env)
{
;call %c_int @putchar(%c_int ASCII_L)
    %isAtom = call NILCC i1 @IsAtom(%Exp %exp)
    br i1 %isAtom, label %Atom, label %Cell

Atom:
    %isNil = call NILCC i1 @IsNil(%Exp %exp)

    ; Non-nil would be weird--evaluating a dotted pair

    ; FIXME: obviously this has to report an error, not explode all
    ; over the user.  There isn't yet any way for the user to cause
    ; this though.
    assert(%isNil)
    ret %Exp %exp

Cell:
    %car = call NILCC %Exp @nil_car(%Exp %exp)
    %first = call NILCC %Exp @Eval(%Exp %car, %Exp %env)

    %cdr = call NILCC %Exp @nil_cdr(%Exp %exp)
    %rest = call NILCC %Exp @EvalList(%Exp %cdr, %Exp %env)

    %cons = call NILCC %Exp @nil_cons(%Exp %first, %Exp %rest)

    ret %Exp %cons
}

;**********************************************************************
; DiscardLine
;
;**********************************************************************

define NILCC void
@DiscardLine()
{
    br label %Loop

Loop:
    %parseExp = call NILCC %ParseExp @GetParseExp()
    %parseExpType = extractvalue %ParseExp %parseExp, 0

    switch %c_int %parseExpType, label %Loop [

        %c_int NIL_EXCEPTION, label  %Exception

        %c_int ASCII_NEWLINE,  label %Done
    ]

Exception:
    %exception = extractvalue %ParseExp %parseExp, 1
    switch %Exp %exception, label %CantHappen [

        %Exp NIL_EOF,          label %Done
        %Exp NIL_IOERROR,      label %Done
        %Exp NIL_BADCHAR,      label %Loop
        %Exp NIL_EXTRA_RPAREN, label %Loop
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

Done:
    call NILCC void @UngetParseExp(%ParseExp %parseExp)
    ret void
}

;**********************************************************************
; NewlineIf
;
;**********************************************************************

define NILCC void
@NewlineIf(i1 %cond)
{
    br i1 %cond, label %Newline, label %Done

Newline:
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    br label %Done

Done:
    ret void
}

;**********************************************************************
; Some interpreter messages
;
;**********************************************************************

#define WELCOMEARRAY_LEN 62
@welcomeArray = internal constant [WELCOMEARRAY_LEN x %c_char]
    c"Welcome to nil v0.0.5.  Press <ctrl>-D at the prompt to exit.\00"

#define PROMPTARRAY_LEN 6
@promptArray = internal constant [PROMPTARRAY_LEN x %c_char]
    c"nil> \00"

#define KNOWNARRAY_LEN 16
@knownArray = internal constant [KNOWNARRAY_LEN x %c_char]
    c"Known strings: \00"

#define BADCHARARRAY_LEN 16
@badCharArray = internal constant [BADCHARARRAY_LEN x %c_char]
    c"#bad character#\00"

#define IOERRORARRAY_LEN 20
@ioErrorArray = internal constant [IOERRORARRAY_LEN x %c_char]
    c"I/O error on input.\00"

#define RPARENARRAY_LEN 14
@rParenArray = internal constant [RPARENARRAY_LEN x %c_char]
    c"Unmatched ')'\00"

;**********************************************************************
; main
;
;**********************************************************************

define %c_int
@main(%c_int %argc, %c_char **%argv)
{
    ; This flag is necessary to avoid double-spacing the prompt when
    ; nothing was entered.
    %hadInputPtr = alloca i1
    store i1 0, i1* %hadInputPtr

    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    %welcomeString = getelementptr [WELCOMEARRAY_LEN x %c_char]*
                                           @welcomeArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %welcomeString)
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    br label %PrintPrompt

PrintPrompt:
    ; Show the current list of strings before each new prompt
    %knownStr = getelementptr [KNOWNARRAY_LEN x %c_char]* @knownArray,
                                                          i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %knownStr)
    call NILCC void @PrintAllStrings()
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)

    ; Print the prompt
    %promptString = getelementptr [PROMPTARRAY_LEN x %c_char]*
                                           @promptArray, i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %promptString)
    br label %ReadExp

ReadExp:
    %parseExp = call NILCC %ParseExp @Read()
    %code = extractvalue %ParseExp %parseExp, 0
    ; Because of single assignment, this is more convenient
    ; to load here even though only Newline and the exception
    ; handlers need it
    %hadInput = load i1* %hadInputPtr

    switch %c_int %code, label %PrintChar [

        %c_int NIL_SYMBOL,   label   %EvalExp
        %c_int NIL_CELL,     label   %EvalExp

        %c_int ASCII_NEWLINE,  label %NewLine

        %c_int NIL_EXCEPTION, label  %Exception
    ]

PrintChar:
    call ccc %c_int @putchar(%c_int %code)
    call ccc %c_int @putchar(%c_int ASCII_SPACE)
    store i1 1, i1* %hadInputPtr
    br label %ReadExp

EvalExp:
    %unevalExp = extractvalue %ParseExp %parseExp, 1
    %exp = call NILCC %Exp @Eval(%Exp %unevalExp, %Exp NIL_VALUE)
    call NILCC void @PrintExp(%Exp %exp)
    call ccc %c_int @putchar(%c_int ASCII_SPACE)
    store i1 1, i1* %hadInputPtr
    br label %ReadExp

NewLine:
    call NILCC void @NewlineIf(i1 %hadInput)
    store i1 0, i1* %hadInputPtr
    br label %PrintPrompt

Exception:
    %exception = extractvalue %ParseExp %parseExp, 1

    switch %Exp %exception, label %CantHappen [

        %Exp NIL_EOF,          label %Exit
        %Exp NIL_IOERROR,      label %ExitIOError
        %Exp NIL_BADCHAR,      label %WarnBadChar
        %Exp NIL_EXTRA_RPAREN, label %ExtraRParen
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

ExitIOError:
    %ioErrorMsg = getelementptr [IOERRORARRAY_LEN x %c_char]*
                        @ioErrorArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %ioErrorMsg)
    br label %Exit

WarnBadChar:
    call NILCC void @NewlineIf(i1 %hadInput)
    %badCharMsg = getelementptr [BADCHARARRAY_LEN x %c_char]*
                        @badCharArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %badCharMsg)
    store i1 0, i1* %hadInputPtr
    call NILCC void @DiscardLine()
    br label %ReadExp

ExtraRParen:
    call NILCC void @NewlineIf(i1 %hadInput)
    %rParenMsg = getelementptr [RPARENARRAY_LEN x %c_char]*
                        @rParenArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %rParenMsg)
    store i1 0, i1* %hadInputPtr
    call NILCC void @DiscardLine()
    br label %ReadExp

Exit:
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    ret %c_int 0
}

