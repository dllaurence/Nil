;**********************************************************************
; nil.llm
;
; Nil main program

; Coding conventions: all native quantities that have a direct correspondence
; with something in lisp are named "nil_<name>" where <name> is the name
; recognized by Nil.
;
; Similarly, all quantities imported from C source have a "c_" prefix
; (obviously quantites defined in libc, such as printf, have their standard
; name).
;
; The above rules apply to macros, but in all caps.
;
; Everything else is an implementation-defined quantity not visible to
; Nil.  They are in my C++ camel case convention (initial cap is a type
; or function, initial small is a variable) to further distinguish them
; from the above.  Also, I am using a 'p' prefix to denote pointers where
; it seems to clarify the code, but probably not consistently.
;
; Finally, to avoid horrible confusion, when it appear by itself or in English
; text the name of the language Nil is always capitalized and the name of the
; empty list nil is always in all lowercase.
;
; Organization: basically like C, with .llh #include files for public module
; declarations and .llm module implementation files.  Note that for ease of
; development I have not always divided the project into as many modules as
; it would have for a finished work, however the modules should be obvious and
; easily broken out as becomes convenient.  Also note that the c_defs and
; system modules have different rules.
;
; Cheats:
;
;   * Using malloc()
;   * Using getchar and other stdio functions instead of read() and write().
;   * Using the C string-handling functions.  Would prefer counted
;     strings anyway.
;
; Copyright 2009-2010 by Dustin Laurence.  Distributed under the terms of
; the LGPLv3.
;
;**********************************************************************

#include "nil.llh"
#include "system.llh"
#include "exp.llh"
#include "memory.llh"
#include "parse.llh"

; For now, we'll leave the definition here in the main module.
; For now, we are maintaining the definition here and the declarations
; in other files by hand because LLVM would call this a redefinition of
; an external declaration. :-(
    @exceptionCode = global %Word 0

;**********************************************************************
; nil_quit
;
;**********************************************************************

    %QuitArrayType = type [5 x %c_char]
    @quitArray = internal constant %QuitArrayType c"quit\00"
    @quitStrPtr = internal constant %c_char* 
                  getelementptr (%QuitArrayType* @quitArray, i64 0, i64 0)

define NILCC %Exp
@nil_quit(%Exp %exp)
{
    call ccc void @exit(%c_int 0)
    unreachable
    ret %Exp NIL_VALUE
}

;**********************************************************************
; nil_quote
;
;**********************************************************************

    %QuoteArrayType = type [6 x %c_char]
    @quoteArray = internal constant %QuoteArrayType c"quote\00"
    @quoteStrPtr = internal constant %c_char*
                   getelementptr (%QuoteArrayType* @quoteArray, i64 0, i64 0)

define NILCC %Exp
@nil_quote(%Exp %exp)
{
    %car = call NILCC %Exp @Car(%Exp %exp)
    ret %Exp %car
}

;**********************************************************************
; nil_car
;
;**********************************************************************

    %CARArrayType = type [4 x %c_char]
    @carArray = internal constant %CARArrayType c"car\00"
    @carStrPtr = internal constant %c_char*
                   getelementptr (%CARArrayType* @carArray, i64 0, i64 0)

    %CARExpectedListType = type [19 x %c_char]
    @carExpectedListArray = internal constant %CARExpectedListType
        c"car: expected list\00"

define NILCC %Exp
@nil_car(%Exp %exp)
{
    %arg = call NILCC %Exp @Car(%Exp %exp)

    %isCell = call NILCC i1 @IsCell(%Exp %arg)
    br i1 %isCell, label %HaveCell, label %NoCell

NoCell:
    ; This is an error, throw an exception
    %carExpectedListPtr = getelementptr %CARExpectedListType*
        @carExpectedListArray, i64 0, i64 0
    call %c_int @puts(%c_char* %carExpectedListPtr)
    %xpn = call NILCC %Exp @Exception2Exp(%Word NIL_EXPECTED_LIST)
    ret %Exp %xpn

HaveCell:
    %car = call NILCC %Exp @Car(%Exp %arg)
    ret %Exp %car
}

;**********************************************************************
; nil_cdr
;
;**********************************************************************

    %CDRArrayType = type [4 x %c_char]
    @cdrArray = internal constant %CDRArrayType c"cdr\00"
    @cdrStrPtr = internal constant %c_char*
                   getelementptr (%CDRArrayType* @cdrArray, i64 0, i64 0)

    %CDRExpectedListType = type [19 x %c_char]
    @cdrExpectedListArray = internal constant %CDRExpectedListType
        c"cdr: expected list\00"

define NILCC %Exp
@nil_cdr(%Exp %exp)
{
    %arg = call NILCC %Exp @Car(%Exp %exp)

    %isCell = call NILCC i1 @IsCell(%Exp %arg)
    br i1 %isCell, label %HaveCell, label %NoCell

NoCell:
    ; This is an error, throw an exception
    %cdrExpectedListPtr = getelementptr %CDRExpectedListType*
        @cdrExpectedListArray, i64 0, i64 0
    call %c_int @puts(%c_char* %cdrExpectedListPtr)
    %xpn = call NILCC %Exp @Exception2Exp(%Word NIL_EXPECTED_LIST)
    ret %Exp %xpn

HaveCell:
    %cdr = call NILCC %Exp @Cdr(%Exp %arg)
    ret %Exp %cdr
}

;**********************************************************************
; nil_cons
;
;**********************************************************************

    %ConsArrayType = type [5 x %c_char]
    @consArray = internal constant %ConsArrayType c"cons\00"
    @consStrPtr = internal constant %c_char*
                   getelementptr (%ConsArrayType* @consArray, i64 0, i64 0)

define NILCC %Exp
@nil_cons(%Exp %exp)
{
    %car = call NILCC %Exp @Car(%Exp %exp)
    %cdr = call NILCC %Exp @Cdr(%Exp %exp)
    %cadr = call NILCC %Exp @Car(%Exp %cdr)

    %cons = call NILCC %Exp @Cons(%Exp %car, %Exp %cadr)
    ret %Exp %cons
}

;**********************************************************************
; AddBinding
;
; Add a binding to a context.
;
;**********************************************************************

define NILCC %Exp
@AddBinding(%c_char** %namePtr, %Exp %value, %Exp %context)
{
    %name = load %c_char** %namePtr
    %sym = call NILCC %Exp @NewSymbol(%c_char* %name)
    %cdr = call NILCC %Exp @Cons(%Exp %value, %Exp NIL_VALUE)
    %binding = call NILCC %Exp @Cons(%Exp %sym, %Exp %cdr)
    %newContext = call NILCC %Exp @Cons(%Exp %binding,
                                           %Exp %context)

    ret %Exp %newContext
}

;**********************************************************************
; AddPrimitiveBinding
;
;**********************************************************************

define NILCC %Exp
@AddPrimitiveBinding
    (
    %c_char** %namePtr,
    %Exp (%Exp)* %fn,
    %Word %nArgs,
    %Exp %context,
    i1 %magic
    )
{
    %name = load %c_char** %namePtr
    %prim = call NILCC %Exp @NewPrimitive(%Exp (%Exp)* %fn, %Word %nArgs,
                                          %c_char* %name, i1 %magic)
    %newContext = call NILCC %Exp @AddBinding(%c_char** %namePtr,
                                              %Exp %prim,
                                              %Exp %context)
    ret %Exp %newContext
}

;**********************************************************************
; GetEnv
;
; Constructs the top-level environment
;
;**********************************************************************

define NILCC %Exp
@GetEnv()
{
    ; Command primitives--these are conceptually ways to control the
    ; interpreter rather than language elements per se, though in
    ; reality there is no difference
    %commandContext = call NILCC %Exp @AddPrimitiveBinding(%c_char** @quitStrPtr,
                      %Exp(%Exp)* @nil_quit, %Word 0, %Exp NIL_VALUE, i1 1)

    %env1 = call NILCC %Exp @Cons(%Exp %commandContext, %Exp NIL_VALUE)

    ; Language primitives
    ; quote
    %langContext1 = call NILCC %Exp @AddPrimitiveBinding(%c_char** @quoteStrPtr,
                    %Exp(%Exp)* @nil_quote, %Word 1, %Exp NIL_VALUE, i1 1)

    ; car
    %langContext2 = call NILCC %Exp @AddPrimitiveBinding(%c_char** @carStrPtr,
                    %Exp(%Exp)* @nil_car, %Word 1, %Exp %langContext1, i1 0)

    ; cdr
    %langContext3 = call NILCC %Exp @AddPrimitiveBinding(%c_char** @cdrStrPtr,
                    %Exp(%Exp)* @nil_cdr, %Word 1, %Exp %langContext2, i1 0)

    ; cons
    %langContext = call NILCC %Exp @AddPrimitiveBinding(%c_char** @consStrPtr,
                   %Exp(%Exp)* @nil_cons, %Word 2, %Exp %langContext3, i1 0)

    %env = call NILCC %Exp @Cons(%Exp %langContext, %Exp %env1)

#if 1
; Debugging code to show the binding list on startup
call %c_int @putchar(%c_int ASCII_NEWLINE)
call NILCC void @PrintExp(%Exp %env)
call %c_int @putchar(%c_int ASCII_NEWLINE)
#endif

    ret %Exp %env
}

;**********************************************************************
; nil_assoc
;
; Takes a list of associations, where each association is a list with
; the key in the first position.  This is probably the same as assoc
; in standard lisp.
;
; We'll only use two-element associations, but the code is general for
; re-use in-language.  For that reason, this should perhaps move to
; the exp module, or a separate library of primitives.
;
;**********************************************************************

    %AssocExpectedListType = type [21 x %c_char]
    @assocExpectedListArray = internal constant %AssocExpectedListType
        c"assoc: expected list\00"

    %ExpectedBindingType = type [24 x %c_char]
    @expectedBindingArray = internal constant %ExpectedBindingType
        c"assoc: expected binding\00"

define NILCC %Exp
@nil_assoc(%Exp %key, %Exp %assocList)
{
    %isList = call NILCC i1 @IsCell(%Exp %assocList)
    br i1 %isList, label %HaveList, label %HaveAtomTag

HaveAtomTag:
    %haveNil = call NILCC i1 @IsNil(%Exp %assocList)
    br i1 %haveNil, label %HaveNil, label %HaveAtom

HaveNil:
    ; The empty list is a list that contains no bindings, so valid
    ; This is our "not found" return value
    ret %Exp NIL_VALUE

HaveAtom:
    ; This is an error, throw an exception
    %assocExpectedListPtr = getelementptr %AssocExpectedListType*
        @assocExpectedListArray, i64 0, i64 0
    call %c_int @puts(%c_char* %assocExpectedListPtr)
    br label %Exception

Exception:
    %xpn = call NILCC %Exp @Exception2Exp(%Word NIL_EXPECTED_LIST)
    ret %Exp %xpn

HaveList:
    %firstBinding = call NILCC %Exp @Car(%Exp %assocList)

    ; Is this really a binding?  It needs to be a cell, but
    ; can be arbitrary otherwise
    %isBinding = call NILCC i1 @IsCell(%Exp %firstBinding)
    br i1 %isBinding, label %HaveBinding, label %NotBinding

NotBinding:
    ; we can't interpret this object, so throw an exception
    ; This is an error, throw an exception
    %expectedBindingPtr = getelementptr %ExpectedBindingType*
        @expectedBindingArray, i64 0, i64 0
    call %c_int @puts(%c_char* %expectedBindingPtr)
    br label %Exception

HaveBinding:
    ; Does the first entry have the key?
    %thisKey = call NILCC %Exp @Car(%Exp %firstBinding)
    %notFound = call NILCC i1 @NotEq(%Exp %key, %Exp %thisKey)
    br i1 %notFound, label %NotFound, label %Found

Found:
    ; Note that we return the entire association--this allows,
    ; among other things, distinguishing between finding a nil
    ; value and finding no value
    ret %Exp %firstBinding

NotFound:
    %restAssoc = call NILCC %Exp @Cdr(%Exp %assocList)
    ; Trivial tail call
    %binding = call NILCC %Exp @nil_assoc(%Exp %key, %Exp %restAssoc)

    ret %Exp %binding
}

;**********************************************************************
; EnvLookup
;
;**********************************************************************

    %UnknownSymbolType = type [16 x %c_char]
    @unknownSymbolArray = internal constant %UnknownSymbolType
        c"unknown symbol \00"

define NILCC %Exp
@EnvLookup(%Exp %exp, %Exp %env)
{
    %cellp = call NILCC i1 @IsCell(%Exp %env)
    br i1 %cellp, label %IsCell, label %NotCell

NotCell:
    %nilp = call NILCC i1 @IsNil(%Exp %env)
    br i1 %nilp, label %UnknownSymbol, label %NotNil

NotNil:
    ; This can't happen if the nil code is correct
    cant_happen()
    br label %NotNil

UnknownSymbol:
    %unknownSymbolPtr = getelementptr
        %UnknownSymbolType* @unknownSymbolArray, i64 0, i64 0
    call %c_int @putstring(%c_char* %unknownSymbolPtr)
    call NILCC void @PrintExp(%Exp %exp)
    call %c_int @putchar(%c_int ASCII_NEWLINE)
    %xpn = call NILCC %Exp @Exception2Exp(%Word NIL_UNKNOWN_SYMBOL)
    ret %Exp %xpn

IsCell:
    %context = call NILCC %Exp @Car(%Exp %env)
    %binding = call NILCC %Exp @nil_assoc(%Exp %exp, %Exp %context)

        #ifndef NDEBUG
        ; When used internally, should be impossible for assoc
        ; to throw an exception
        %notException = call NILCC i1 @NotException(%Exp %binding)
        assert(%notException)
        #endif

    %found = call NILCC i1 @NotNil(%Exp %binding)
    br i1 %found, label %FoundSymbol, label %NotFound

NotFound:
    ; Recurse and check next context
    %outerEnv = call NILCC %Exp @Cdr(%Exp %env)
    %outerBinding = call NILCC %Exp @EnvLookup(%Exp %exp, %Exp %outerEnv)
    ret %Exp %outerBinding

FoundSymbol:
    %cdr = call NILCC %Exp @Cdr(%Exp %binding)

        #ifndef NDEBUG
        ; Must be a list
        %isCell = call NILCC i1 @IsCell(%Exp %cdr)
        assert(%isCell)
        ; Must be a 1-element list--we have no good use for anything
        ; else!
        %cddr = call NILCC %Exp @Cdr(%Exp %cdr)
        %isNil = call NILCC i1 @IsNil(%Exp %cddr)
        assert(%isNil)
        #endif

    %cadr = call NILCC %Exp @Car(%Exp %cdr)
    ret %Exp %cadr
}

;**********************************************************************
; Eval
;
;**********************************************************************

define NILCC %Exp
@Eval(%Exp %exp, %Exp %env)
{
;call %c_int @putchar(%c_int ASCII_E)
    %tag = call NILCC %Tag @GetTag(%Exp %exp)

        ; Remember that here we will only see types produced by the
        ; parser, not all types in the language, and the top level
        ; caller will filter out parser exceptions for us.

    switch %Tag %tag, label %CantHappen [
        %Tag CELL_TAG,      label %Cell
        %Tag SYMBOL_TAG,    label %SymbolTag
#if 0
        %Tag INTEGER_TAG,   label %SelfEvaluate
#endif
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

Cell:
    ; I claim apply should control the evaluation of its arguments,
    ; so contrary to SICP we just pass the expression on
    %return = call NILCC %Exp @Apply(%Exp %exp, %Exp %env)
    ret %Exp %return

SymbolTag:
    ;%evalExp = call NILCC %Exp @EnvLookup(%Exp %exp, %Exp %env)
    ;ret %Exp %evalExp

    %notNil = call NILCC i1 @NotNil(%Exp %exp)
    br i1 %notNil, label %Symbol, label %SelfEvaluate
    ; for now
    ;br label %IsNil

SelfEvaluate:
    ; nil is self-evaluating
    ret %Exp %exp

Symbol:
    ; May be an exception
    %value = call NILCC %Exp @EnvLookup(%Exp %exp, %Exp %env)
#if 0
; Debugging code to print the symbol found in angle brackets
call %c_int @putchar(%c_int ASCII_LANGLE)
call NILCC void @PrintExp(%Exp %value)
call %c_int @putchar(%c_int ASCII_RANGLE)
call %c_int @putchar(%c_int ASCII_NEWLINE)
#endif
    ret %Exp %value
}

;**********************************************************************
; Apply
;
;**********************************************************************

    %CannotApplyType = type [14 x %c_char]
    @cannotApplyArray = internal constant %CannotApplyType
        c"cannot apply \00"

    %BadArgNumType = type [32 x %c_char]
    @badArgNumArray = internal constant %BadArgNumType
        c"had %ld arguments, required %ld\00"

define NILCC %Exp
@Apply(%Exp %combination, %Exp %env)
{
Initial:
;call %c_int @putchar(%c_int ASCII_A)

        #ifndef NDEBUG
        %isCell = call NILCC i1 @IsCell(%Exp %combination)
        assert(%isCell)
        #endif

    %car = call NILCC %Exp @Car(%Exp %combination)

    ; For now, always evaluate the function.  This may have to
    ; change when we get to implementing user functions and
    ; lambda, we'll see
    %fn = call NILCC %Exp @Eval(%Exp %car, %Exp %env)

    %tag = call NILCC %Tag @GetTag(%Exp %fn)

        ; Remember that here we will only see types produced by the
        ; parser, not all types in the language, and the top level
        ; caller will filter out parser exceptions for us.

    switch %Tag %tag, label %CantHappen [
        %Tag EXCEPTION_TAG, label %Exception
        %Tag CELL_TAG,      label %CannotApply
        %Tag SYMBOL_TAG,    label %CannotApply
        %Tag PRIMITIVE_TAG, label %Primitive
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

Exception:
    ret %Exp %fn

CannotApply:
    %cannotApplyPtr = getelementptr %CannotApplyType* @cannotApplyArray,
                                     i64 0, i64 0
    call %c_int @putstring(%c_char* %cannotApplyPtr)
    call NILCC void @PrintExp(%Exp %fn)
    call %c_int @putchar(%c_int ASCII_NEWLINE)
    %xpn = call NILCC %Exp @Exception2Exp(%Word NIL_CANNOT_APPLY)
    ret %Exp %xpn

Primitive:
    %prim = call NILCC %nil_primitive* @Exp2nil_primitive(%Exp %fn)
    %primFnPtr = getelementptr %nil_primitive* %prim, i64 0, i32 0
    %primFn = load %Exp (%Exp)** %primFnPtr

    %primArgNumPtr = getelementptr %nil_primitive* %prim, i64 0, i32 1
    %primArgNum = load %Word* %primArgNumPtr

    %cdr = call NILCC %Exp @Cdr(%Exp %combination)
    %argNum = call NILCC %Word @Len(%Exp %cdr)

    %goodArgNum = icmp eq %Word %argNum, %primArgNum
    br i1 %goodArgNum, label %GoodArgNum, label %BadArgNum

BadArgNum:
    %badArgNumStr = getelementptr %BadArgNumType* @badArgNumArray, i64 0, i64 0
    call %c_int (%c_char*, ...)* @printf(%c_char* %badArgNumStr, %Word %argNum,
                                         %Word %primArgNum)
    call %c_int @putchar(%c_int ASCII_NEWLINE)
    %badArgsXpn = call NILCC %Exp @Exception2Exp(%Word NIL_BAD_ARG_NUM)
    ret %Exp %badArgsXpn

GoodArgNum:
    %magicPtr = getelementptr %nil_primitive* %prim, i64 0, i32 3
    %magic = load i1* %magicPtr
    br i1 %magic, label %IsMagic, label %NotMagic

NotMagic:
    %evalArgs = call NILCC %Exp @EvalList(%Exp %cdr, %Exp %env)
    %argException = call NILCC i1 @IsException(%Exp %evalArgs)
    br i1 %argException, label %ArgException, label %IsMagic

ArgException:
    ret %Exp %evalArgs

IsMagic:
    %args = phi %Exp [%evalArgs, %NotMagic], [%cdr, %GoodArgNum]
    %result = call NILCC %Exp %primFn(%Exp %args)
    ret %Exp %result
}

;**********************************************************************
; EvalList
;
;**********************************************************************

    #define DOTPAIRARRAY_LEN 36
    %DotPairType = type [DOTPAIRARRAY_LEN x %c_char]
    @dotPairArray = internal constant %DotPairType
        c"Error: can't evaluate a dotted pair\00"

define NILCC %Exp
@EvalList(%Exp %exp, %Exp %env)
{
;call %c_int @putchar(%c_int ASCII_L)
    %isAtom = call NILCC i1 @IsAtom(%Exp %exp)
    br i1 %isAtom, label %Atom, label %Cell

Atom:
    %isNil = call NILCC i1 @IsNil(%Exp %exp)
    br i1 %isNil, label %IsNil, label %NotNil

IsNil:
    ret %Exp %exp

NotNil:
    ; FIXME: when we have the ability to produce dotted pairs,
    ; this code needs to be tested
    ; Weird--evaluating a dotted pair
    %dotPairString = getelementptr %DotPairType* @dotPairArray,
                                                    i64 0, i64 0
    call ccc %c_int @puts(%c_char* %dotPairString)
    call %c_int @putchar(%c_int ASCII_NEWLINE)
    %errorExp = call NILCC %Exp @Exception2Exp(%Word NIL_EVAL_DOTPAIR)
    ret %Exp %errorExp

Cell:
    %car = call NILCC %Exp @Car(%Exp %exp)
    %first = call NILCC %Exp @Eval(%Exp %car, %Exp %env)
    %firstOK = call NILCC i1 @NotException(%Exp %first)
    br i1 %firstOK, label %DoCDR, label %Exception

DoCDR:
    %cdr = call NILCC %Exp @Cdr(%Exp %exp)
    %rest = call NILCC %Exp @EvalList(%Exp %cdr, %Exp %env)
    %restOK = call NILCC i1 @NotException(%Exp %rest)
    br i1 %restOK, label %DoCons, label %Exception

DoCons:
    %cons = call NILCC %Exp @Cons(%Exp %first, %Exp %rest)
    ret %Exp %cons

Exception:
    %xpn = phi %Exp [%first, %Cell], [%rest, %DoCDR]
    ret %Exp %xpn
}

;**********************************************************************
; DiscardLine
;
;**********************************************************************

define NILCC void
@DiscardLine()
{
    br label %Loop

Loop:
    %parseExp = call NILCC %ParseExp @GetParseExp()
    %parseExpType = extractvalue %ParseExp %parseExp, 0

    switch %c_int %parseExpType, label %Loop [

        %c_int NIL_EXCEPTION, label  %Exception

        %c_int ASCII_NEWLINE,  label %Done
    ]

Exception:
    %exception = extractvalue %ParseExp %parseExp, 1
    switch %Exp %exception, label %CantHappen [

        %Exp NIL_EOF,          label %Done
        %Exp NIL_IOERROR,      label %Done
        %Exp NIL_BADCHAR,      label %Loop
        %Exp NIL_EXTRA_RPAREN, label %Loop
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

Done:
    call NILCC void @UngetParseExp(%ParseExp %parseExp)
    ret void
}

;**********************************************************************
; NewlineIf
;
;**********************************************************************

define NILCC void
@NewlineIf(i1 %cond)
{
    br i1 %cond, label %Newline, label %Done

Newline:
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    br label %Done

Done:
    ret void
}

;**********************************************************************
; PrintWelcome
;
;**********************************************************************

    #define WELCOMEARRAY_LEN 62
    @welcomeArray = internal constant [WELCOMEARRAY_LEN x %c_char]
        c"Welcome to nil v0.0.7.  Enter '(quit)' at the prompt to exit.\00"

define NILCC void
@PrintWelcome()
{
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    %welcomeString = getelementptr [WELCOMEARRAY_LEN x %c_char]*
                                           @welcomeArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %welcomeString)
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)

    ret void
}

;**********************************************************************
; PrintPrompt
;
;**********************************************************************

    #define KNOWNARRAY_LEN 16
    @knownArray = internal constant [KNOWNARRAY_LEN x %c_char]
        c"Known strings: \00"

    #define PROMPTARRAY_LEN 6
    @promptArray = internal constant [PROMPTARRAY_LEN x %c_char]
        c"nil> \00"

define NILCC void
@PrintPrompt()
{
#if 0
    ; Show the current list of strings before each new prompt
    %knownStr = getelementptr [KNOWNARRAY_LEN x %c_char]* @knownArray,
                                                          i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %knownStr)
    call NILCC void @PrintAllStrings()
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
#endif

    ; Print the prompt
    %promptString = getelementptr [PROMPTARRAY_LEN x %c_char]*
                                           @promptArray, i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %promptString)

    ret void
}

;**********************************************************************
; PrintResultPrefix
;
;**********************************************************************

    #define RESULTARRAY_LEN 9
    %ResultArrayType = type [RESULTARRAY_LEN x %c_char]
    @resultArray = internal constant %ResultArrayType
        c"    ==> \00"

define NILCC void
@PrintResultPrefix()
{
    %resultString = getelementptr %ResultArrayType*
                                           @resultArray, i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %resultString)

    ret void
}

;**********************************************************************
; HandleParserException
;
;**********************************************************************

    #define BADCHARARRAY_LEN 16
    @badCharArray = internal constant [BADCHARARRAY_LEN x %c_char]
        c"#bad character#\00"

    #define IOERRORARRAY_LEN 20
    @ioErrorArray = internal constant [IOERRORARRAY_LEN x %c_char]
        c"I/O error on input.\00"

    #define RPARENARRAY_LEN 14
    @rParenArray = internal constant [RPARENARRAY_LEN x %c_char]
        c"Unmatched ')'\00"

define NILCC i1
@HandleParserException(%Exp %code)
{
    switch %Exp %code, label %CantHappen [

        %Exp NIL_EOF,          label %EOF
        %Exp NIL_IOERROR,      label %IOError
        %Exp NIL_BADCHAR,      label %BadChar
        %Exp NIL_EXTRA_RPAREN, label %ExtraRParen
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

EOF:
    ret i1 false

IOError:
    %ioErrorMsg = getelementptr [IOERRORARRAY_LEN x %c_char]*
                        @ioErrorArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %ioErrorMsg)
    ret i1 false

BadChar:
    %badCharMsg = getelementptr [BADCHARARRAY_LEN x %c_char]*
                        @badCharArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %badCharMsg)
    call NILCC void @DiscardLine()
    ret i1 true

ExtraRParen:
    %rParenMsg = getelementptr [RPARENARRAY_LEN x %c_char]*
                        @rParenArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %rParenMsg)
    call NILCC void @DiscardLine()
    ret i1 true
}

;**********************************************************************
; main
;
;**********************************************************************

define %c_int
@main(%c_int %argc, %c_char **%argv)
{
    ; This flag is necessary to avoid double-spacing the prompt when
    ; nothing was entered.
    %hadInputPtr = alloca i1
    store i1 0, i1* %hadInputPtr

    ; The initial evaluation environment
    %env = call NILCC %Exp @GetEnv()

    call NILCC void @PrintWelcome()
    br label %Prompt

Prompt:
    call NILCC void @PrintPrompt()
    br label %ReadExp

ReadExp:
    %parseExp = call NILCC %ParseExp @Read()
    %code = extractvalue %ParseExp %parseExp, 0
    ; Because of single assignment, this is more convenient
    ; to load here even though only Newline and the exception
    ; handlers need it
    %hadInput = load i1* %hadInputPtr

    switch %c_int %code, label %CantHappen [

        %c_int NIL_EXCEPTION, label   %ParseException

        %c_int ASCII_NEWLINE, label   %NewLine

        %c_int NIL_SYMBOL,    label   %EvalExp
        %c_int NIL_CELL,      label   %EvalExp
#if 0
        %c_int NIL_INTEGER,   label   %EvalExp
#endif
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

ParseException:
    call NILCC void @NewlineIf(i1 %hadInput)
    %exception = extractvalue %ParseExp %parseExp, 1
    %continue = call NILCC i1 @HandleParserException(%Exp %exception)
    store i1 0, i1* %hadInputPtr
    br i1 %continue, label %ReadExp, label %Exit

NewLine:
    call NILCC void @NewlineIf(i1 %hadInput)
    store i1 0, i1* %hadInputPtr
    br label %Prompt

EvalExp:
    %unevalExp = extractvalue %ParseExp %parseExp, 1
    %exp = call NILCC %Exp @Eval(%Exp %unevalExp, %Exp %env)
    call NILCC void @PrintResultPrefix()
    call NILCC void @PrintExp(%Exp %exp)

    ; If we got an exception, toss the rest of the line
    %evalOK = call NILCC i1 @NotException(%Exp %exp)
    br i1 %evalOK, label %EvalOK, label %EvalException

EvalException:
    call NILCC void @DiscardLine()
    br label %EvalOK

EvalOK:
    call ccc %c_int @putchar(%c_int ASCII_SPACE)
    store i1 1, i1* %hadInputPtr
    br label %ReadExp

Exit:
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    ret %c_int 0
}

