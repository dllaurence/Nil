;**********************************************************************
; nil.llm
;
; Nil main program

; Coding conventions: all native quantities that have a direct correspondence
; with something in lisp are named "nil_<name>" where <name> is the name
; recognized by Nil.
;
; Similarly, all quantities imported from C source have a "c_" prefix
; (obviously quantites defined in libc, such as printf, have their standard
; name).
;
; The above rules apply to macros, but in all caps.
;
; Everything else is an implementation-defined quantity not visible to
; Nil.  They are in my C++ camel case convention (initial cap is a type
; or function, initial small is a variable) to further distinguish them
; from the above.  Also, I am using a 'p' prefix to denote pointers where
; it seems to clarify the code, but probably not consistently.
;
; Finally, to avoid horrible confusion, when it appear by itself or in English
; text the name of the language Nil is always capitalized and the name of the
; empty list nil is always in all lowercase.
;
; Organization: basically like C, with .llh #include files for public
; module declarations and .llm module implementation files.  Note that
; for ease of development I have not divided the project into as many
; modules as it would have for a finished work, however the modules
; should be obvious and easily broken out.  Also note that the c_defs and
; system modules have different rules.
;
; Cheats:
;
;   * Using malloc()
;   * Using getchar and other stdio functions instead of read() and write().
;
; Copyright 2009 by Dustin Laurence.  Distributed under the terms of
; the LGPLv3.
;
;**********************************************************************

#include "nil.llh"
;#include "exp.llh"

;**********************************************************************
; I/O
;
;**********************************************************************

#define IO_EOF      -1
#define IO_ERROR    -10

;**********************************************************************
; getchar_simple
;
; Simplifies the use of C getchar() by calling the feof and ferror
; functions on behalf of the caller and only reporting ultimate error
; or EOF.
;
;**********************************************************************

define NILCC %c_int
@getchar_simple()
{
    br label %ReadLoop                    ; Dummy basic block

ReadLoop:
    %char = call ccc %c_int @getchar()

    %done = icmp ne %c_int %char, C_EOF
    br i1 %done, label %Success, label %NoChar

NoChar:
   %stdin = call ccc %c_char* @getstdfileptr(%c_int C_STDIN_FD)
   %c_eof = call ccc %c_int @feof(%c_char* %stdin)
   %eofBool = icmp ne %c_int %c_eof, 0
   br i1 %eofBool, label %EOF, label %CheckErr

EOF:
    ret %c_int IO_EOF

CheckErr:
    %c_err = call ccc %c_int @ferror(%c_char* %stdin)
    %errBool = icmp ne %c_int %c_err, 0
    br i1 %errBool, label %Error, label %ReadLoop

Error:
    ret %c_int IO_ERROR

Success:
    ret %c_int %char
}

;**********************************************************************
; Lexer
;
;**********************************************************************

#define LEX_FINISHED IO_EOF

; Some ASCII values; not special to the lexer so could go into system.llh
#define ASCII_TAB        9
#define ASCII_NEWLINE   10
#define ASCII_VTAB      11
#define ASCII_FORMFEED  12
#define ASCII_CR        13
#define ASCII_SPACE     32
#define ASCII_DEL      127

;**********************************************************************
; NextChar (private)
;
; Simplifies the lexer by letting us filter out illegal characters.
; Prints an error message if there is a bad character, and returns
; LEX_FINISHED on either a bad character or EOF.
;
;**********************************************************************

@badCharArray = internal constant [24 x %c_char] c"Bad character on input.\00"
@ioErrorArray = internal constant [20 x %c_char] c"I/O error on input.\00"

define NILCC %c_int
@NextChar()
{
    %nextChar = call NILCC %c_int @getchar_simple()
    switch %c_int %nextChar, label %ValidIO [
        %c_int IO_EOF,      label %Finished
        %c_int IO_ERROR,    label %OnIOError

        %c_int ASCII_TAB,      label %AcceptNextChar
        %c_int ASCII_NEWLINE,  label %AcceptNextChar
        %c_int ASCII_VTAB,     label %AcceptNextChar
        %c_int ASCII_FORMFEED, label %AcceptNextChar
        %c_int ASCII_CR,       label %AcceptNextChar
    ]

ValidIO:
    %smallEnough = icmp slt %c_int %nextChar, ASCII_DEL
    br i1 %smallEnough, label %SmallEnough,
                        label %BadChar

SmallEnough:
    %printing = icmp sge %c_int %nextChar, ASCII_SPACE
    br i1 %printing, label %AcceptNextChar,
                     label %BadChar

AcceptNextChar:
    ret %c_int %nextChar

; This is the only exceptional return value, as we've already
; taken care of elementary error reporting

Finished:
    ret %c_int LEX_FINISHED

; Handle Exceptional Conditions

BadChar:
    %badCharMsg = getelementptr [24 x %c_char]*
                        @badCharArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %badCharMsg)
    br label %Finished

OnIOError:
    %ioErrorMsg = getelementptr [20 x %c_char]*
                        @ioErrorArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %ioErrorMsg)
    br label %Finished
}

;**********************************************************************
; main
;
;**********************************************************************

define %c_int
@main(%c_int %argc, %c_char **%argv)
{
    ; Dummy basic block, because we can't branch to the first block
    br label %ReadChar

    ; At this stage main is playing
ReadChar:
    %char = call NILCC %c_int @NextChar()
    %finished = icmp eq %c_int %char, LEX_FINISHED
    br i1 %finished, label %Exit, label %PrintChar

PrintChar:
    call ccc %c_int @putchar(%c_int %char)
    br label %ReadChar

Exit:
    ret %c_int 0
}

