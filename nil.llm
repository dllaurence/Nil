;**********************************************************************
; nil.llm
;
; Nil main program

; Coding conventions: all native quantities that have a direct correspondence
; with something in lisp are named "nil_<name>" where <name> is the name
; recognized by Nil.
;
; Similarly, all quantities imported from C source have a "c_" prefix
; (obviously quantites defined in libc, such as printf, have their standard
; name).
;
; The above rules apply to macros, but in all caps.
;
; Everything else is an implementation-defined quantity not visible to
; Nil.  They are in my C++ camel case convention (initial cap is a type
; or function, initial small is a variable) to further distinguish them
; from the above.  Also, I am using a 'p' prefix to denote pointers where
; it seems to clarify the code, but probably not consistently.
;
; Finally, to avoid horrible confusion, when it appear by itself or in English
; text the name of the language Nil is always capitalized and the name of the
; empty list nil is always in all lowercase.
;
; Organization: basically like C, with .llh #include files for public module
; declarations and .llm module implementation files.  Note that for ease of
; development I have not always divided the project into as many modules as
; it would have for a finished work, however the modules should be obvious and
; easily broken out as becomes convenient.  Also note that the c_defs and
; system modules have different rules.
;
; Cheats:
;
;   * Using malloc()
;   * Using getchar and other stdio functions instead of read() and write().
;   * Using the C string-handling functions.  Would prefer counted
;     strings anyway.
;
; Copyright 2009-2010 by Dustin Laurence.  Distributed under the terms of
; the LGPLv3.
;
;**********************************************************************

#include "nil.llh"
#include "system.llh"
#include "lex.llh"

;**********************************************************************
; Strings
;
; (Placed here until I decide the best place to factor it out.)
;
; A simple little module that ensures that every string *value* is
; stored in a single unique location, vital for Lisp to work with any
; kind of efficiency at all (among other things, this means we can
; test for symbol equality with a simple pointer compare).  A simple
; linked list is more than sufficient for now.
;
; Note that as far as this module is concerned "" is a perfectly valid
; symbol. :-)
;
;**********************************************************************

%StringList = type {%c_char*, %StringList*}

@ppListHead = internal global %StringList* null

;**********************************************************************
; UniqueString
;
; Returns a pointer to a unique string with the same contents as the
; given string, allocating if necessary.  Note that the caller can't
; free() the string as we maintain an internal pointer to it.  That's
; what garbage collection is for.
;
;**********************************************************************

define NILCC %c_char*
@UniqueString(%c_char* %string)
{
    ; Is there already such a string in the list?
    %existingString = call NILCC %c_char* @FindString(%c_char* %string)

    #ifndef NDEBUG
    ; For paranoia's sake, in debugging mode we'll do the same search
    ; all over again with the recursive implementation and assert that
    ; precisely the same pointer is obtained.
    %pListHead = load %StringList** @ppListHead
    %alternateString = call NILCC %c_char* @FindStringR(%StringList* %pListHead,
                                                        %c_char* %string)
    %equal = icmp eq %c_char* %existingString, %alternateString
    assert(%equal)
    #endif

    %exists = icmp ne %c_char* %existingString, null
    br i1 %exists, label %ReturnOldString, label %GetNewString

ReturnOldString:
; These blocks are very useful for verifying that the code is re-using
; old strings as it should, so I'll leave them here for the time being.
; It prepends a (O) or an (N) to symbols as they are echoed back
; depending on whether it returned an (O)ld or (N)ew object.
#if 0
call ccc %c_int @putchar(%c_int ASCII_LPAREN)
call ccc %c_int @putchar(%c_int ASCII_O)
call ccc %c_int @putchar(%c_int ASCII_RPAREN)
#endif
    ; If so, return it.
    ret %c_char* %existingString

GetNewString:
#if 0
call ccc %c_int @putchar(%c_int ASCII_LPAREN)
call ccc %c_int @putchar(%c_int ASCII_N)
call ccc %c_int @putchar(%c_int ASCII_RPAREN)
#endif
    ; If not, allocate a new string with that value...
    %newString = call ccc %c_char* @strdup(%c_char* %string)
    #ifndef NDEBUG
    ; Did we get it?
    %gotString = icmp ne %c_char* %newString, null
    assert(%gotString)
    ; Also check to see that the alignment is OK, because we're paranoid
    %addr = ptrtoint %c_char* %newString to %Word
    %tag = and %Word %addr, 7 ; 2^3-1
    %aligned = icmp eq %Word %tag, 0
    assert(%aligned)
    #endif

    ; ...add it to the list...
    call NILCC void @PushString(%c_char* %newString)

    ; ...and return it.
    ret %c_char* %newString
}

;**********************************************************************
; PushString
;
; Adds the given string to the head of the list without checking to
; see if it is already present.
;
;**********************************************************************

define NILCC void
@PushString(%c_char* %string)
{
    ; Compute sizeof(StringList)
    %sizeAddr = getelementptr %StringList* null, i64 1
    %size = ptrtoint %StringList* %sizeAddr to %c_size_t

    ; Get a new StringList element
    %newMem = call ccc i8* @malloc(%c_size_t %size)
    %gotMem = icmp ne i8* %newMem, null
    assert(%gotMem)
    %newElement = bitcast i8* %newMem to %StringList*

    ; Set the element to point to that string
    %stringField = getelementptr %StringList* %newElement, i32 0, i32 0
    store %c_char* %string, %c_char** %stringField

    ; Point its next field at the current head
    %nextField = getelementptr %StringList* %newElement, i32 0, i32 1
    %oldHead = load %StringList** @ppListHead
    store %StringList* %oldHead, %StringList** %nextField

    ; Make it the new head
    store %StringList* %newElement, %StringList** @ppListHead

    ret void
}

;**********************************************************************
; FindString
;
; Returns a pointer to the unique string in the list with the same
; contents as the given string, if it exists.  Otherwise, return null.
;
; Written in imperative style--this is LLVM, not lisp.  However, it
; might be educational to see it in recursive style, and LLVM claims
; to be able to optimize tail calls.
;
;**********************************************************************

define NILCC %c_char*
@FindString(%c_char* %searchString)
{
    ; Paranoia--disallow calls with null (empty strings are fine)
    #ifndef NDEBUG
    %haveInput = icmp ne %c_char* %searchString, null
    assert(%haveInput)
    #endif

    ; StringList *pThisElement
    %ppThisElement = alloca %StringList*

    ; pThisElement = &ListHead
    %pListHead = load %StringList** @ppListHead
    store %StringList* %pListHead, %StringList** %ppThisElement
    br label %Loop

Loop:
    ; while (pThisElement != null)
    %pThisElement = load %StringList** %ppThisElement
    %notNull = icmp ne %StringList* %pThisElement, null
    br i1 %notNull, label %BeginLoop, label %EndLoop

    BeginLoop:
        ; if (pThisElement->string == searchString)
        ; FIXME: should use the LLVM 2.6 inbounds keyword
        %thisStringPtr = getelementptr %StringList* %pThisElement, i32 0, i32 0
        %thisString = load %c_char** %thisStringPtr
        %cmp = call ccc %c_int @strcmp(%c_char* %thisString,
                                       %c_char* %searchString)
        %equal = icmp eq %c_int %cmp, 0
        br i1 %equal, label %BeginIf, label %EndIf

        BeginIf:

            ; return thisElement->string
            ret %c_char* %thisString

        EndIf:
        ; thisElement = thisElement->next
        %nextElementPtr = getelementptr %StringList* %pThisElement, i32 0, i32 1
        %nextElement = load %StringList** %nextElementPtr
        store %StringList* %nextElement, %StringList** %ppThisElement
        br label %Loop

EndLoop:
    ; We didn't find it, return null
    ret %c_char* null
}

;**********************************************************************
; FindStringR
;
; Precisely the same semantics as FindString, but written in recursive
; style for comparison purposes.  We've helped LLVM compile it to an
; iterative process by explicitly specifying a tail call.
;
;**********************************************************************

define NILCC %c_char*
@FindStringR(%StringList* %list, %c_char* %searchString)
{
    ; Paranoia--disallow calls with null (empty strings are fine)
    #ifndef NDEBUG
    %haveInput = icmp ne %c_char* %searchString, null
    assert(%haveInput)
    #endif

    %notNull = icmp ne %StringList* %list, null
    br i1 %notNull, label %NotNull, label %IsNull

IsNull:
    ; We didn't find it, return null
    ret %c_char* null

NotNull:
    ; if (pThisElement->string == searchString)
    ; FIXME: should use the LLVM 2.6 inbounds keyword
    %thisStringPtr = getelementptr %StringList* %list, i32 0, i32 0
    %thisString = load %c_char** %thisStringPtr
    %cmp = call ccc %c_int @strcmp(%c_char* %thisString,
                                   %c_char* %searchString)
    %equal = icmp eq %c_int %cmp, 0
    br i1 %equal, label %StringsEqual, label %StringsNotEqual

StringsEqual:

    ; return thisElement->string
    ret %c_char* %thisString

StringsNotEqual:
    ; thisElement = thisElement->next
    %nextElementPtr = getelementptr %StringList* %list, i32 0, i32 1
    %nextElement = load %StringList** %nextElementPtr
    %answer = tail call NILCC %c_char* @FindStringR(%StringList* %nextElement,
                                                    %c_char* %searchString)
    ret %c_char* %answer
}

;**********************************************************************
; NextToken (public)
;
; The front end of the nil tokenizer.  Constructs the tokens required
; by the parser from the lexemes identified by NextLexeme().  Part of
; the expression module because when complete it will know about
; expression types.
;
;**********************************************************************

%Token = type {%c_int, %c_char*}
 
define NILCC void
@NextToken(%Token* %token)
{
    %tokenType = call NILCC %c_int @NextLexeme()

    ; Set up both pointers here for convenience
    %typeFieldPtr = getelementptr %Token* %token, i32 0, i32 0
    %lexemeFieldPtr = getelementptr %Token* %token, i32 0, i32 1

    store %c_int %tokenType, %c_int* %typeFieldPtr

    switch %c_int %tokenType, label %CantHappen [

        %c_int LEX_EOF,        label %ReturnCode
        %c_int LEX_IOERROR,    label %ReturnCode
        %c_int LEX_BADCHAR,    label %ReturnCode

        %c_int ASCII_NEWLINE,  label %ReturnCode

        %c_int ASCII_LPAREN,   label %ReturnCode
        %c_int ASCII_RPAREN,   label %ReturnCode
        %c_int LEX_SYMBOL,     label %ReturnSymbol
    ]

CantHappen:
    cant_happen()
    br label %CantHappen

ReturnCode:
    store %c_char* null, %c_char** %lexemeFieldPtr
    ret void

ReturnSymbol:
    %lexeme = call NILCC %c_char* @GetLexemePtr()
    #ifndef NDEBUG
    %len = call ccc %c_size_t @strlen(%c_char* %lexeme)
    %positive = icmp ugt %c_size_t %len, 0
    assert(%positive)
    ; Buffer size not available to this module to check
    #endif

    ; Allocate a string
    %string = call NILCC %c_char* @UniqueString(%c_char* %lexeme)

    #ifndef NDEBUG
    ; Test that a second call obtains the same ptr
    #endif

    store %c_char* %string, %c_char** %lexemeFieldPtr
    ret void
}

;**********************************************************************
; Some interpreter messages
;
;**********************************************************************

#define WELCOMEARRAY_LEN 62
@welcomeArray = internal constant [WELCOMEARRAY_LEN x %c_char]
    c"Welcome to nil v0.0.2.  Press <ctrl>-D at the prompt to exit.\00"

#define PROMPTARRAY_LEN 6
@promptArray = internal constant [PROMPTARRAY_LEN x %c_char] c"nil> \00"

#define BADCHARARRAY_LEN 16
@badCharArray = internal constant [BADCHARARRAY_LEN x %c_char]
    c"#bad character#\00"

#define IOERRORARRAY_LEN 20
@ioErrorArray = internal constant [IOERRORARRAY_LEN x %c_char]
    c"I/O error on input.\00"

;**********************************************************************
; main
;
;**********************************************************************

define %c_int
@main(%c_int %argc, %c_char **%argv)
{
    %tokenPtr = alloca %Token

    ; This flag is necessary to avoid double-spacing the prompt when
    ; nothing was entered.
    %hadInputPtr = alloca i1
    store i1 0, i1* %hadInputPtr

    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    %welcomeString = getelementptr [WELCOMEARRAY_LEN x %c_char]*
                                           @welcomeArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %welcomeString)
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    br label %PrintPrompt

PrintPrompt:
    %promptString = getelementptr [PROMPTARRAY_LEN x %c_char]*
                                           @promptArray, i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %promptString)
    br label %ReadChar

ReadChar:
    ;%code = call NILCC %c_int @NextLexeme()
    call NILCC void @NextToken(%Token* %tokenPtr)
    %codePtr = getelementptr %Token* %tokenPtr, i32 0, i32 0
    %code = load %c_int* %codePtr

    switch %c_int %code, label %PrintChar [

        %c_int LEX_EOF,      label %Exit
        %c_int LEX_IOERROR,  label %ExitIOError
        %c_int LEX_BADCHAR,  label %WarnBadChar
        %c_int LEX_SYMBOL,   label %PrintSymbol

        %c_int ASCII_NEWLINE,  label %NewLine
    ]

PrintChar:
    call ccc %c_int @putchar(%c_int %code)
    call ccc %c_int @putchar(%c_int ASCII_SPACE)
    store i1 1, i1* %hadInputPtr
    br label %ReadChar

ExitIOError:
    %ioErrorMsg = getelementptr [IOERRORARRAY_LEN x %c_char]*
                        @ioErrorArray, i64 0, i64 0
    call ccc %c_int @puts(%c_char* %ioErrorMsg)
    store i1 1, i1* %hadInputPtr
    br label %Exit

WarnBadChar:
    %badCharMsg = getelementptr [BADCHARARRAY_LEN x %c_char]*
                        @badCharArray, i64 0, i64 0
    call ccc %c_int @putstring(%c_char* %badCharMsg)
    call ccc %c_int @putchar(%c_int ASCII_SPACE)
    store i1 1, i1* %hadInputPtr
    br label %ReadChar

PrintSymbol:
    ;%lexeme = call NILCC %c_char* @GetLexemePtr()
    %lexemePtr = getelementptr %Token* %tokenPtr, i32 0, i32 1
    %lexeme = load %c_char** %lexemePtr
    call ccc %c_int @putstring(%c_char* %lexeme)
    call ccc %c_int @putchar(%c_int ASCII_SPACE)
    store i1 1, i1* %hadInputPtr
    br label %ReadChar

NewLine:
    %hadInput = load i1* %hadInputPtr
    br i1 %hadInput, label %IfHadInput, label %EndIfHadInput
    IfHadInput:
        call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
        br label %EndIfHadInput
    EndIfHadInput:

    store i1 0, i1* %hadInputPtr
    br label %PrintPrompt

Exit:
    call ccc %c_int @putchar(%c_int ASCII_NEWLINE)
    ret %c_int 0
}

